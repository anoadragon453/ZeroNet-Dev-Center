<!DOCTYPE html>
<html lang="en">
<head>
	<title>ZeroNet Dev Center</title>
	<meta charset="utf-8">
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="keywords" content="zite,zites,important,krixano,list,category,search,filter">
	<meta name="author" content="Krixano">
	<meta name="description" content="Center for ZeroNet Development. Tutorials, Collaboration, Questions">
	<base href="" target="_top" id="base">
	<script>base.href = document.location.href.replace("/media", "").replace("index.html", "").replace(/[&?]wrapper=False/, "").replace(/[&?]wrapper_nonce=[A-Za-z0-9]+/, "")</script>

	<link rel="stylesheet" href="font-awesome-4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="css/buefy.css" />
	<link rel="stylesheet" href="css/main.css" />

	<script src="js/navToggle.js" defer></script>
</head>
<body>
	<div id="app">
		<my-hero v-bind:class="{ 'is-medium': heroIsMedium }" v-bind:title="heroTitle" v-bind:subtitle="heroSubtitle">
			<div v-html="heroContent"></div>
		</my-hero>

		<component v-bind:is="currentView" v-bind:current-authaddress="currentAuthaddress" v-bind:tutorials-list="tutorialsList" v-bind:blog-posts="blogPosts" v-bind:tutorial-content="tutorialContent" v-bind:tableofcontents="tableOfContents" v-bind:tutorial-comments="comments" v-bind:questions-list="questionsList" v-bind:reference-id="referenceID" v-bind:date-added="dateAdded" v-bind:answers-list="answersList" v-bind:question-title="questionTitle" v-bind:question-subtitle="questionSubtitle" v-bind:question-comments="comments" v-bind:question-authaddress="questionAuthaddress" v-bind:solutionid="solutionid" v-bind:solution-authaddress="solutionAuthaddress" v-bind:all-comments="allComments"></component>

		<my-footer></my-footer>
	</div>

	<!-- ZeroFrame -->
	<script type="text/javascript" src="js/ZeroFrame.js"></script>

	<!-- Vue & Router -->
	<script type="text/javascript" src="js/vue.min.js"></script>
	<script type="text/javascript" src="js/router.js"></script>
	<script type="text/javascript" src="js/vue-zeroframe-router.js"></script>
	<script type="text/javascript" src="js/vueComponents.js"></script>
	<script type="text/javascript" src="js/vueRoutes.js"></script>
	<script type="text/javascript" src="js/vue-async-computed.js"></script>

	<!-- Bulma and Buefy -->
	<script type="text/javascript" src="js/buefy.js"></script>

	<!-- Markdown-It -->
	<script type="text/javascript" src="js/markdown-it/markdown-it.min.js"></script>
	<script type="text/javascript" src="js/markdown-it/markdown-it-footnote.min.js"></script>
	<script type="text/javascript" src="js/markdown-it/markdown-it-emoji-light.min.js"></script>
	<script type="text/javascript" src="js/markdown-it/markdown-it-abbr.min.js"></script>
	<script type="text/javascript" src="js/markdown-it/markdown-it-deflist.min.js"></script>

	<!-- Moment JS -->
	<script type="text/javascript" src="js/moment.js"></script>

	<!-- HighlightJS -->
	<link rel="stylesheet" href="js/highlightjs/styles/atom-one-light.css">
	<script type="text/javascript" src="js/highlightjs/highlight.pack.js">
	<script>hljs.initHighlightingOnLoad();</script>

	<script>
		// Markdown It
		var md = window.markdownit();
		md.use(window.markdownitFootnote);
		md.use(window.markdownitEmoji);
		md.use(window.markdownitAbbr);
		md.use(window.markdownitDeflist);
		md.set({
			html: true,
			highlight: function (str, lang) {
				if (lang && hljs.getLanguage(lang)) {
					try {
					  return hljs.highlight(lang, str).value;
					} catch (__) {}
				}

				return ''; // use external default escaping
			}
		});

		// Vue
		Vue.use(Buefy);
		Vue.use(AsyncComputed);
		Vue.use(VueZeroFrameRouter);

		var app = new Vue({
			data: {
				site_info: null,
				currentView: null,
				currentAuthaddress: '',
				heroIsMedium: true,
				heroTitle: "",
				heroSubtitle: "",
				heroContent: "",
				blogPosts: [],
				tutorialsList: [],
				referenceID: null,
				dateAdded: null,
				tutorialContent: "",
				tableOfContents: "",
				comments: [],
				allComments: [],
				userComments: [], // TODO: Change this to use allComments instead
				questionsList: [],
				questionTitle: "",
				questionSubtitle: "",
				questionAuthaddress: "",
				solutionid: null,
				solutionAuthaddress: "",
				answersList: [],
				allAnswersList: []
			}
		}).$mount('#app');

		// ZeroFrame
		class ZeroApp extends ZeroFrame {
			onOpenWebsocket () {
				this.cmd("siteInfo", {}, (site_info) => {
					this.site_info = site_info;
					fillInCurrentUser();
					app.currentAuthaddress = this.site_info.auth_address;
					getUsersComments();
				});
				this.cmd("wrapperNotification", ["info", "This is the DEV version of the zite."]);
			}

			selectUser () {
				this.cmd("certSelect", {accepted_domains: ["zeroid.bit", "kaffie.bit", "cryptoid.bit"]})
				return false
			}

			onRequest (cmd, message) {
				if (cmd == "setSiteInfo") {
					this.site_info = message.params;  // Save site info data to allow access it later
					app.currentAuthaddress = this.site_info.auth_address;
					fillInCurrentUser();
					getUsersComments();
					if (message.params.event[0] == "file_done") {
						checkTutorialsList(true);
						if (Router.currentRoute == "tutorials/:slug") {
							getComments(app.referenceID, "t");
						} else if (Router.currentRoute == "questions") {
							getQuestionsList();
						} else if (Router.currentRoute == "questions/:certuserid/:id") {
							getQuestion(app.referenceID, app.questionAuthaddress);
							//getCommentsWithAuthaddress(app.referenceID, app.questionAuthaddress, "q");
							//getAnswersList(app.referenceID, app.questionAuthaddress);
							//getAllComments();
						} else if (Router.currentRoute == "blog") {
							getBlogPosts(null, true);
						} else if (Router.currentRoute == "blog/:slug") {
							// TODO: Update blog post
							//getBlogPost(app.);
							getComments(app.referenceID, 'b');
						} else if (Router.currentRoute == "") {
							getQuestionsList();
						}
					}
				}

				Router.listenForBack(cmd, message);
			}
		}

		zeroframe = new ZeroApp();
		page = zeroframe; // NOTE: For ZeroFrame Router


		// ZeroFrame Router
		// Route Components are declared in the js/vueRoutes.js file.
		VueZeroFrameRouter_Init(app, [
			{ route: 'tutorials/:slug', component: TutorialsSlug },
			{ route: 'tutorials', component: Tutorials },
			{ route: 'questions/new', component: QuestionsNew },
			{ route: 'questions/:certuserid/:id/answer', component: QuestionsCertuseridIdAnswer },
			{ route: 'questions/:certuserid/:id/edit', component: QuestionsCertuseridIdEdit },
			{ route: 'questions/:certuserid/:id', component: QuestionsCertuseridId },
			{ route: 'questions', component: Questions },
			{ route: 'blog/:slug', component: BlogSlug },
			{ route: 'blog', component: Blog },
			{ route: '', component: Home }
		]);

		// Change the content in the hero.
		function setupHero(isMedium, title, subtitle, content = "") {
			if (isMedium != null) {
				app.heroIsMedium = isMedium;
			}
			if (title != null) {
				app.heroTitle = title;
			}
			if (subtitle != null) {
				app.heroSubtitle = subtitle;
			}
			if (content != null) {
				app.heroContent = content;
			}
		}

		// Change innerHTML of all elements with class of 'currentuser' to
		// the current user's cert_user_id, or a Select User link when there isn't
		// a current user selected. This is called everytime a route is loaded
		// and when the current user changes.
		function fillInCurrentUser() {
			var elements = document.querySelectorAll('.currentuser');
			for (var i = 0; i < elements.length; i++) {
				if (zeroframe.site_info.cert_user_id) {
					if (elements[i].parentElement.tagName == "A" || elements[i].parentElement.tagName == "BUTTON") {
						elements[i].innerHTML = zeroframe.site_info.cert_user_id;
					} else {
						elements[i].innerHTML = '<a href="#Select+user" onclick="return zeroframe.selectUser()">' + zeroframe.site_info.cert_user_id + '</a>';
					}
				} else {
					if (elements[i].parentElement.tagName == "A" || elements[i].parentElement.tagName == "BUTTON") {
						elements[i].innerHTML = "Select User";
					} else {
						elements[i].innerHTML = '<a href="#Select+user" onclick="return zeroframe.selectUser()">Select User</a>';
					}
				}
			}
		}

		// Called from oninput of textarea, passes in 'this' so the function can
		// use it's height and scrollHeight.
		function expandTextarea(textarea) {
			textarea.style.height = "";
			textarea.style.height = textarea.scrollHeight + "px";
			if (textarea.style["overflow-y"] != "hidden") {
				textarea.style["overflow-y"] = "hidden";
			}
		}

		function getBlogPosts(f = null, refresh = false) {
			if (app.blogPosts.length == 0 || refresh) {
				zeroframe.cmd('dbQuery', ['SELECT * FROM blogposts'], (posts) => {
					app.blogPosts = posts;
					if (f && typeof f == 'function') f();
				});
			}
		}

		function getBlogPost(slug, f = null) {
			if (slug) {
				var getBlogPost = function(blogPosts) {
					var post = null;
					for (var i in blogPosts) {
						if (blogPosts[i].slug == slug) {
							post = blogPosts[i];
						}
					}

					if (post) {
						app.tutorialContent = md.render(post.body);
						app.heroTitle = post.title;
						app.heroSubtitle = "Published on " + moment(this.dateAdded).format('MMMM Do, YYYY');
						app.referenceID = post.post_id;
						app.dateAdded = post.date_added;

						getComments(post.post_id, "b", f);
					} else {
						app.tutorialContent = "";
						app.heroTitle = 'Not Found';
						app.heroSubtitle = 'This page was not found!';
						app.dateAdded = null;
					}
				};

				if (app.blogPosts.length == 0) {
					zeroframe.cmd('dbQuery', ['SELECT * FROM blogPosts'], (blogPosts) => getBlogPost(blogPosts));
				} else {
					getBlogPost(app.blogPosts);
				}
			}
		}

		// Get's all tutorials from database and caches it in app.tutorialsList
		// TODO(krixano): Recache tutorial list when tutorials database changes
		function checkTutorialsList(refresh = false) {
			if (app.tutorialsList.length == 0 || refresh) {
				zeroframe.cmd('dbQuery', ['SELECT * FROM tutorials'], (tutorials) => {
					app.tutorialsList = tutorials;
				});
			}
		}

		// Get the tutorial from the tutorialList, get its markdown file,
		// and convert it into html, and generate a table of contents based on
		// the main headings.
		// Afterwards, call the getComments function.
		// TODO?(krixano): Implement caching of last visited tutorial's text?
		function getTutorial(slug, f = null) {
			if (slug) {
				var getTutorial = function(tutorials) {
					var tutorial = null;
					for (var i in tutorials) {
						if (tutorials[i].slug == slug) {
							tutorial = tutorials[i];
						}
					}

					if (tutorial) {
						zeroframe.cmd('fileGet', ['tutorials/' + tutorial.file], (content) => {
							app.heroTitle = tutorial.title;
							app.heroSubtitle = 'By ' + tutorial.author;
							app.tutorialContent = md.render(content);
							app.referenceID = tutorial.id;
							app.dateAdded = tutorial.date_added;

							// Generate Table Of Contents
							var tableOfContents = "<ol>";
							var headings = app.tutorialContent.match(/<(h2)[^>]*>([^<]+)<\/(h2)>/g);
							for (var i = 0; i < headings.length; i++) {
								tableOfContents += "<li><a href='#h" + i + "'>" + headings[i].replace(/<h2[^>]*>/, '').replace(/<\/h2>/, '') + "</a></li>";
							}
							tableOfContents += "</ol>";
							app.tableOfContents = tableOfContents;

							getComments(tutorial.id, "t", f);
						});
					} else {
						app.tutorialContent = "";
						app.heroTitle = 'Not Found';
						app.heroSubtitle = 'This page was not found!';
						app.dateAdded = null;
						// Router.navigate('not-found');
					}
				};

				if (app.tutorialsList.length == 0) {
					zeroframe.cmd('dbQuery', ['SELECT * FROM tutorials'], (tutorials) => getTutorial(tutorials));
				} else {
					getTutorial(app.tutorialsList);
				}
			}
		}

		// Get comments that reference given id and type from database.
		// Usually used when the referenced post is a Tutorial.
		// ReferenceTypes:
		// t - tutorial
		// q - question
		// a - answer
		// b - blog post
		function getComments(referenceID, referenceType, f = null) {
			zeroframe.cmd("dbQuery", ["SELECT * FROM comments LEFT JOIN json USING (json_id) WHERE reference_id=" + referenceID + " AND reference_type='" + referenceType + "' ORDER BY date_added DESC"], (comments) => {
				app.comments = comments;
				if (f && typeof f == 'function') f();
			});
		}

		// Get all comments from database.
		function getAllComments(f = null) {
			zeroframe.cmd("dbQuery", ["SELECT * FROM comments LEFT JOIN json USING (json_id) ORDER BY date_added DESC"], (comments) => {
				app.allComments = comments;
				if (f && typeof f == 'function') f();
			});
		}

		// Get current user's comments from database.
		// TODO: Change this to use getAllComments instead (and cache the comments and check whether they are already downloaded, etc)?
		function getUsersComments(f = null) {
			zeroframe.cmd("dbQuery", ["SELECT * FROM comments LEFT JOIN json USING (json_id) ORDER BY date_added DESC"], (comments) => {
				app.usersComments = comments;
				if (f && typeof f == 'function') f();
			});
		}

		// Get all comments that reference given id, type, and auth_address of
		// the user where the json file that contains the referenced post is located.
		// Usually used when the referenced post is a Question. NOTE: Answers use getAllComments isntead!
		// ReferenceTypes:
		// t - tutorial
		// q - question
		// a - answer
		// b - blog post
		function getCommentsWithAuthaddress(referenceID, auth_address, referenceType) {
			if (referenceType == "t") {
				console.log("ERROR: getCommentsWithAuthaddress doesn't work with tutorials.");
				return;
			}

			zeroframe.cmd("dbQuery", ["SELECT * FROM comments LEFT JOIN json USING (json_id) WHERE reference_id=" + referenceID + " AND reference_auth_address='" + auth_address + "' AND reference_type='" + referenceType + "' ORDER BY date_added DESC"], (comments) => {
				app.comments = comments;
			});
		}

		// Post a comment referencing a post of given type with given id from json
		// file located in the directory of the user whose auth_address matches
		// the given auth_address.
		// ReferenceTypes:
		// t - tutorial
		// q - question
		// a - answer
		// b - blog post
		function postComment(referenceType, referenceID, referenceAuthAddress = null, refreshComments = true, f = null) {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			// Load our current messages
			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (data)
					data = JSON.parse(data);
				else
					data = { "comments": [], "questions": [], "answers": [] }

				// Get list of comments from current user
				var usersComments = app.usersComments.filter((comment) => {
					//return comment.cert_user_id == zeroframe.site_info.cert_user_id;
					return comment.directory.replace(/users\//, '').replace(/\//g, '') == zeroframe.site_info.auth_address;
				});
				// Get current user's last comment's id and increment by 1
				var commentID = 1;
				if (usersComments.length > 0) {
					commentID += usersComments[0].comment_id;
				}

				// Add the new message to data
				data.comments.push({
					"comment_id": commentID,
					"reference_id": referenceID,
					"reference_type": referenceType,
					"reference_auth_address": referenceAuthAddress,
					"body": document.getElementById("comment").value,
					"date_added": Date.now()
				});

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						// Reset the message input
						document.getElementById("comment").value = "";

						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Reload comments
							if (refreshComments) {
								if (referenceAuthAddress) {
									getCommentsWithAuthaddress(app.referenceID, referenceAuthAddress, referenceType);
								} else {
									getComments(app.referenceID, referenceType);
								}
							}

							if (f && typeof f == 'function') f();

							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}

		// Overwrite answer of given id with new body from given textarea
		function editComment(commentID, bodyTextarea, commentAuthaddress, referenceType, referenceAuthAddress = null) {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// Check that the current user is equal to the question's user.
			if (app.currentAuthaddress != commentAuthaddress) {
				console.log("You cannot edit this. This question doesn't belong to you!");
				zeroframe.cmd("wrapperNotification", ["info", "You cannot edit this. This question doesn't belong to you!"]);
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (!data) {
					console.log("ERROR: No data for the current user. Cannot edit comment that doesn't exist.");
					return;
				}
				data = JSON.parse(data);

				for (var i = 0; i < data.comments.length; i++) {
					var comment = data.comments[i];
					if (comment.comment_id == commentID) {
						comment.body = bodyTextarea.value;
						// TODO: Add date_edited column to comments (and questions, and answers)
					}
				}

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Refresh Comments
							if (referenceAuthAddress) {
								getCommentsWithAuthaddress(app.referenceID, referenceAuthAddress, referenceType);
							} else {
								getComments(app.referenceID, referenceType);
							}
							getUsersComments(); // WOW! This code is TERRIBLE! TODO: Make this code not terrible!
							getAllComments();

							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}

		// Get list of all questions from database.
		function getQuestionsList(f = null) {
			zeroframe.cmd('dbQuery', ['SELECT * FROM questions LEFT JOIN json USING (json_id) ORDER BY date_added DESC'], (questions) => {
				app.questionsList = questions;
				if (f && typeof f == 'function') f();
			});
		}

		// Determins in the current user can edit the current question. If it can,
		// app.showEdit is set to true, which will display the edit button.
		function questionAllowEdit() {
			app.showEdit = zeroframe.site_info.auth_address == app.questionAuthaddress;
		}

		// Get question with given id from the data.json file of the user whose
		// auth_address matches given auth_address
		// Set markdown to true if you want app.tutorialContent to be the markdown
		// instead of the html of the markdown.
		function getQuestion(id, auth_address, markdown = false, f = null) {
			if (id && auth_address) {
				var getQuestion = function(questions) {
					var question = null;
					for (var i in questions) {
						if (questions[i].question_id == id) {
							question = questions[i];
						}
					}

					if (question) {
						if (markdown) {
							app.tutorialContent = question.body;
						} else {
							app.tutorialContent = md.render(question.body);
						}
						app.referenceID = question.question_id;
						app.questionTitle = question.title;
						app.questionSubtitle = question.cert_user_id;
						app.questionAuthaddress = question.directory.replace(/users\//, '').replace(/\//g, '');
						app.solutionid = question.solution_id;
						app.solutionAuthaddress = question.solution_auth_address;
						app.dateAdded = question.date_added;

						getCommentsWithAuthaddress(id, auth_address, "q");
						getAnswersList(id, auth_address, f);
					} else {
						app.tutorialContent = "";
						app.heroTitle = 'Not Found';
						app.heroSubtitle = 'This page was not found!';
						if (f && typeof f == 'function') f();
						// Router.navigate('not-found');
					}
				};

				zeroframe.cmd('dbQuery', ['SELECT * FROM questions LEFT JOIN json USING (json_id) WHERE directory="users/' + auth_address + '" ORDER BY date_added DESC'], (questions) => getQuestion(questions));
			}
		}

		// Post a question in the current user's data.json file. The id of the question
		// is 1 more than the id of the user's last question.
		function postQuestion() {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			// Load our current questions
			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (data)
					data = JSON.parse(data);
				else
					data = { "comments": [], "questions": [], "answers": [] }

				// Get list of questions from current user
				var usersQuestions = app.questionsList.filter((question) => {
					//return question.cert_user_id == zeroframe.site_info.cert_user_id;
					return question.directory.replace(/users\//, '').replace(/\//g, '') == zeroframe.site_info.auth_address;
				});
				// Get current user's last question's id and increment by 1
				var questionID = 1;
				if (usersQuestions.length > 0) {
					questionID += usersQuestions[0].question_id;
				}

				// Add the new question to data
				data.questions.push({
					"question_id": questionID,
					"title": document.getElementById("questionTitle").value,
					"body": document.getElementById("questionBody").value,
					"date_added": Date.now()
				});

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						// Reset the question input
						document.getElementById("questionTitle").value = "";
						document.getElementById("questionBody").value = "";

						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Reload Questions List
							getQuestionsList();

							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
							Router.navigate("questions");
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}

		// Overwrite question of given id with new body from textarea with id of 'editQuestionBody'
		function editQuestion(questionID, questionAuthaddress) {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// Check that the current user is equal to the question's user.
			if (app.currentAuthaddress != questionAuthaddress) {
				console.log("You cannot edit this. This question doesn't belong to you!");
				zeroframe.cmd("wrapperNotification", ["info", "You cannot edit this. This question doesn't belong to you!"]);
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (!data) {
					console.log("ERROR: No data for the current user. Cannot edit question that doesn't exist.");
					return;
				}
				data = JSON.parse(data);

				for (var i = 0; i < data.questions.length; i++) {
					var question = data.questions[i];
					if (question.question_id == questionID) {
						question.title = document.getElementById("editQuestionTitle").value;
						question.body = document.getElementById("editQuestionBody").value;
						// TODO: Add date_edited column to questions (and answers)
					}
				}

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						// Reset the question input
						document.getElementById("editQuestionTitle").value = "";
						document.getElementById("editQuestionBody").value = "";

						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
							Router.navigate("questions/" + zeroframe.site_info.auth_address + "/" + questionID);
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}

		function questionMarkSolution(questionID, questionAuthaddress, answerID, answerAuthaddress) {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// Check that the current user is equal to the question's user.
			if (app.currentAuthaddress != questionAuthaddress) {
				console.log("You cannot edit this. This question doesn't belong to you!");
				zeroframe.cmd("wrapperNotification", ["info", "You cannot mark a solution for this question. This question doesn't belong to you!"]);
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (!data) {
					console.log("ERROR: No data for the current user. Cannot mark solution for a question that doesn't exist.");
					return;
				}
				data = JSON.parse(data);

				for (var i = 0; i < data.questions.length; i++) {
					var question = data.questions[i];
					if (question.question_id == questionID) {
						question.solution_id = answerID;
						question.solution_auth_address = answerAuthaddress;
					}
				}

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						app.solutionid = answerID;
						app.solutionAuthaddress = answerAuthaddress;

						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}

		// Get list of all answers that reference a question with given id from
		// a data.json file of a user whose auth_address matches the given auth_address.
		function getAnswersList(id, auth_address, f = null) {
			zeroframe.cmd('dbQuery', ['SELECT * FROM answers LEFT JOIN json USING (json_id) WHERE question_id=' + id + ' AND question_auth_address="' + auth_address + '" ORDER BY date_added DESC'], (answers) => {
				app.answersList = answers;
				if (f && typeof f == 'function') f();
			});
		}

		// Get all answers from database.
		function getAllAnswers() {
			zeroframe.cmd('dbQuery', ['SELECT * FROM answers LEFT JOIN json USING (json_id) ORDER BY date_added DESC'], (answers) => {
				app.allAnswersList = answers;
			});
		}

		// Post an answer referencing the current question's id and the auth_address
		// of the user who posted the question. The current question is loaded,
		// before this function is called, using the getQuestion function (the
		// values in the url are passed in). The id of the answer is 1 more than
		// the current user's last answer's id.
		function postAnswer() {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			// Load our current questions
			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (data)
					data = JSON.parse(data);
				else
					data = { "comments": [], "questions": [], "answers": [] }

				// Get list of answers from current user
				var usersAnswers = app.allAnswersList.filter((answer) => {
					//return answer.cert_user_id == zeroframe.site_info.cert_user_id;
					return answer.directory.replace(/users\//, '').replace(/\//g, '') == zeroframe.site_info.auth_address;
				});
				// Get current user's last answer's id and increment by 1
				var answerID = 1;
				if (usersAnswers.length > 0) {
					answerID += usersAnswers[0].answer_id;
				}

				// Add the new question to data
				data.answers.push({
					"answer_id": answerID,
					"question_id": app.referenceID,
					"question_auth_address": app.questionAuthaddress,
					"body": document.getElementById("answerBody").value,
					"date_added": Date.now()
				});

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						// Reset the question input
						document.getElementById("answerBody").value = "";

						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
							Router.navigate("questions/" + app.questionAuthaddress + '/' + app.referenceID);
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}

		// Overwrite answer of given id with new body from given textarea
		function editAnswer(answerID, bodyTextarea, answerAuthaddress) {
			// No account selected -> Display error
			if (!zeroframe.site_info.cert_user_id) {
				zeroframe.cmd("wrapperNotification", ["info", "Please, select your account."]);
				zeroframe.selectUser();
				return;
			}

			// Check that the current user is equal to the question's user.
			if (app.currentAuthaddress != answerAuthaddress) {
				console.log("You cannot edit this. This question doesn't belong to you!");
				zeroframe.cmd("wrapperNotification", ["info", "You cannot edit this. This question doesn't belong to you!"]);
				return;
			}

			// This is the data file path
			var data_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/data.json";
			var content_inner_path = "data/users/" + zeroframe.site_info.auth_address + "/content.json";

			zeroframe.cmd("fileGet", {"inner_path": data_inner_path, "required": false}, (data) => {
				if (!data) {
					console.log("ERROR: No data for the current user. Cannot edit answer that doesn't exist.");
					return;
				}
				data = JSON.parse(data);

				for (var i = 0; i < data.answers.length; i++) {
					var answer = data.answers[i];
					if (answer.answer_id == answerID) {
						answer.body = bodyTextarea.value;
						// TODO: Add date_edited column to answers (and questions, and comments)
					}
				}

				// Encode data array to utf8 json text
				var json_raw = unescape(encodeURIComponent(JSON.stringify(data, undefined, '\t')));

				// Write file to disk
				zeroframe.cmd("fileWrite", [data_inner_path, btoa(json_raw)], (res) => {
					if (res == "ok") {
						// Sign the changed file in our user's directory
						zeroframe.cmd("siteSign", {"inner_path": content_inner_path}, (res) => {
							// Refresh answers
							getAnswersList(app.referenceID, app.questionAuthaddress);

							// Publish to other users
							zeroframe.cmd("sitePublish", {"inner_path": content_inner_path, "sign": false});
						});
					} else {
						zeroframe.cmd("wrapperNotification", ["error", "File write error: #{res}"]);
					}
				});
			});
		}
	</script>
</body>
</html>
